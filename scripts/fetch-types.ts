import { writeFile } from "node:fs/promises";
import { resolve } from "node:path";

type NamedApiResource = {
  name: string;
  url: string;
};

type TypeListResponse = {
  results: NamedApiResource[];
};

type TypeResponse = {
  name: string;
  names: Array<{
    name: string;
    language: NamedApiResource;
  }>;
  damage_relations: {
    double_damage_to: NamedApiResource[];
    half_damage_to: NamedApiResource[];
    no_damage_to: NamedApiResource[];
  };
};

// PokeAPIのタイプ名を表示順で並べる。
const typeOrder = [
  "normal",
  "fire",
  "water",
  "electric",
  "grass",
  "ice",
  "fighting",
  "poison",
  "ground",
  "flying",
  "psychic",
  "bug",
  "rock",
  "ghost",
  "dragon",
  "dark",
  "steel",
  "fairy",
] as const;

const typeSet = new Set<string>(typeOrder);
const listUrl = "https://pokeapi.co/api/v2/type?limit=1000";
const outputPath = resolve("src/type-chart.ts");

// エラー情報を含めたfetchの薄いラッパー。
const fetchJson = async <T>(url: string) => {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Request failed: ${url} (${response.status})`);
  }
  return (await response.json()) as T;
};

const getJapaneseName = (type: TypeResponse) => {
  const preferredLanguages = ["ja-Hrkt", "ja"];
  for (const lang of preferredLanguages) {
    const entry = type.names.find((name) => name.language.name === lang);
    if (entry) {
      return entry.name;
    }
  }
  return type.name;
};

const list = await fetchJson<TypeListResponse>(listUrl);
const urlByName = new Map(list.results.map((item) => [item.name, item.url]));

// 18タイプを安定した順序で取得。
const types = await Promise.all(
  typeOrder.map(async (name) => {
    const url = urlByName.get(name);
    if (!url) {
      throw new Error(`Type not found in PokeAPI list: ${name}`);
    }
    return await fetchJson<TypeResponse>(url);
  }),
);

const chart: Record<string, Record<string, number>> = {};
const typeNameJaByEn: Record<string, string> = {};

for (const type of types) {
  if (!typeSet.has(type.name)) {
    continue;
  }
  typeNameJaByEn[type.name] = getJapaneseName(type);
  // 全て等倍で初期化し、相性を上書きする。
  const row: Record<string, number> = {};
  for (const defense of typeOrder) {
    row[defense] = 1;
  }
  for (const relation of type.damage_relations.double_damage_to) {
    if (typeSet.has(relation.name)) {
      row[relation.name] = 2;
    }
  }
  for (const relation of type.damage_relations.half_damage_to) {
    if (typeSet.has(relation.name)) {
      row[relation.name] = 0.5;
    }
  }
  for (const relation of type.damage_relations.no_damage_to) {
    if (typeSet.has(relation.name)) {
      row[relation.name] = 0;
    }
  }
  chart[type.name] = row;
}

const typeOrderJa = typeOrder.map((name) => typeNameJaByEn[name] ?? name);
const chartJa: Record<string, Record<string, number>> = {};
for (const attack of typeOrder) {
  const attackJa = typeNameJaByEn[attack] ?? attack;
  const rowJa: Record<string, number> = {};
  for (const defense of typeOrder) {
    const defenseJa = typeNameJaByEn[defense] ?? defense;
    rowJa[defenseJa] = chart[attack][defense];
  }
  chartJa[attackJa] = rowJa;
}

// アプリから取り込めるようTSモジュールとして出力。
const output = `// Generated by scripts/fetch-types.ts\n` +
  `export const typeOrder = ${JSON.stringify(typeOrder)} as const;\n` +
  `export const typeNameJaByEn = ${JSON.stringify(typeNameJaByEn, null, 2)} as const;\n` +
  `export const typeOrderJa = ${JSON.stringify(typeOrderJa)} as const;\n` +
  `export const typeChart = ${JSON.stringify(chart, null, 2)} as const;\n` +
  `export const typeChartJa = ${JSON.stringify(chartJa, null, 2)} as const;\n`;

await writeFile(outputPath, output);
console.log(`Wrote ${outputPath}`);
